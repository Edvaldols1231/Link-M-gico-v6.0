import os
import json
import openai
from typing import Dict, List, Optional, Tuple
import re
from datetime import datetime
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AIConversationEngine:
    """Motor de IA conversacional otimizado para respostas concisas e objetivas"""

    def __init__(self):
        self.client = openai.OpenAI(
            api_key=os.getenv('OPENAI_API_KEY'),
            base_url=os.getenv('OPENAI_API_BASE')
        )
        self.conversation_history = {}
        self.sales_prompts = self._load_sales_prompts()

    def _load_sales_prompts(self) -> Dict[str, str]:
        """Carrega prompts especializados para vendas"""
        return {
            "system_base": """Você é um assistente de vendas profissional.
            Suas respostas devem ser:
            - Curtas e diretas (máximo 2–3 frases)
            - Objetivas, sem floreios ou exageros
            - Sem repetições
            - Tom amigável e profissional
            - Sempre focadas em dados ou benefícios concretos""",

            "greeting": """Cumprimente de forma breve e amigável.
            Use apenas uma frase curta e vá direto ao ponto.""",

            "objection_handling": """O cliente trouxe uma objeção.
            Responda em até 3 frases:
            - Reconheça a preocupação
            - Dê uma resposta objetiva
            - Reforce o benefício principal""",

            "closing": """É hora de fechar a venda.
            Use uma frase curta para reforçar o benefício e convide à ação de forma direta.""",

            "follow_up": """Responda em até 2 frases.
            Mantenha a conversa simples, objetiva e direcionada para o próximo passo."""
        }

    def analyze_user_intent(self, message: str, context: Dict) -> Dict[str, any]:
        """Analisa a intenção do usuário e contexto emocional"""
        try:
            analysis_prompt = f"""
            Analise esta mensagem do usuário e retorne um JSON com:
            - intent: (greeting, question, objection, interest, ready_to_buy, price_inquiry, comparison, other)
            - sentiment: (positive, negative, neutral)
            - urgency_level: (low, medium, high)
            - buying_stage: (awareness, consideration, decision)
            - emotional_state: (excited, skeptical, confused, frustrated, curious)
            - key_concerns: [lista de preocupações identificadas]

            Mensagem: "{message}"
            Contexto da conversa: {json.dumps(context.get('previous_messages', [])[-3:], ensure_ascii=False)}
            """

            response = self.client.chat.completions.create(
                model="gpt-4.1-mini",
                messages=[
                    {"role": "system", "content": "Você é especialista em análise de intenção. Retorne apenas JSON válido."},
                    {"role": "user", "content": analysis_prompt}
                ],
                temperature=0.3,
                max_tokens=200
            )

            return json.loads(response.choices[0].message.content)

        except Exception as e:
            logger.error(f"Erro na análise de intenção: {e}")
            return {
                "intent": "other",
                "sentiment": "neutral",
                "urgency_level": "medium",
                "buying_stage": "consideration",
                "emotional_state": "curious",
                "key_concerns": []
            }

    def generate_persuasive_response(self, message: str, context: Dict, web_data: Optional[Dict] = None, custom_instructions: str = "") -> str:
        """Gera resposta baseada no contexto e dados"""
        try:
            intent_analysis = self.analyze_user_intent(message, context)

            prompt_key = self._select_prompt_strategy(intent_analysis)
            base_prompt = self.sales_prompts.get(prompt_key, self.sales_prompts["follow_up"])

            full_context = self._build_conversation_context(context, web_data, intent_analysis)

            system_message = f"{self.sales_prompts['system_base']}\n\n{base_prompt}\n\nContexto adicional: {full_context}"

            if custom_instructions and custom_instructions.strip():
                system_message += f"\n\nInstruções personalizadas: {custom_instructions.strip()}"

            response = self.client.chat.completions.create(
                model="gpt-4.1-mini",
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": f"Mensagem do cliente: {message}"}
                ],
                temperature=0.3,
                max_tokens=150,
                presence_penalty=0.6,
                frequency_penalty=0.4
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            logger.error(f"Erro na geração de resposta: {e}")
            return self._get_fallback_response(intent_analysis.get("intent", "other"))

    def _select_prompt_strategy(self, intent_analysis: Dict) -> str:
        intent = intent_analysis.get("intent", "other")
        buying_stage = intent_analysis.get("buying_stage", "consideration")

        if intent == "greeting":
            return "greeting"
        elif intent == "objection":
            return "objection_handling"
        elif intent == "ready_to_buy" or buying_stage == "decision":
            return "closing"
        else:
            return "follow_up"

    def _build_conversation_context(self, context: Dict, web_data: Optional[Dict], intent_analysis: Dict) -> str:
        context_parts = []
        if context.get('previous_messages'):
            context_parts.append(f"Histórico recente: {json.dumps(context['previous_messages'][-5:], ensure_ascii=False)}")
        if web_data:
            context_parts.append(f"Dados do produto: {json.dumps(web_data, ensure_ascii=False)}")
        context_parts.append(f"Análise: {json.dumps(intent_analysis, ensure_ascii=False)}")
        return "\n".join(context_parts)

    def _get_fallback_response(self, intent: str) -> str:
        fallbacks = {
            "greeting": "Olá! Como posso ajudar?",
            "objection": "Entendo sua preocupação. Esse ponto tem solução simples.",
            "question": "Boa pergunta. A resposta é simples: ...",
            "other": "Certo. Pode me contar um pouco mais?"
        }
        return fallbacks.get(intent, fallbacks["other"])

    def update_conversation_history(self, session_id: str, user_message: str, bot_response: str, context: Dict):
        if session_id not in self.conversation_history:
            self.conversation_history[session_id] = []

        self.conversation_history[session_id].append({
            "timestamp": datetime.now().isoformat(),
            "user_message": user_message,
            "bot_response": bot_response,
            "context": context
        })

        if len(self.conversation_history[session_id]) > 20:
            self.conversation_history[session_id] = self.conversation_history[session_id][-20:]

    def get_conversation_context(self, session_id: str) -> Dict:
        history = self.conversation_history.get(session_id, [])
        return {
            "previous_messages": [
                {"user": msg["user_message"], "bot": msg["bot_response"]}
                for msg in history[-10:]
            ],
            "session_start": history[0]["timestamp"] if history else datetime.now().isoformat(),
            "total_interactions": len(history)
        }
